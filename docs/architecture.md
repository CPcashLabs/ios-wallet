# Architecture Overview

## Design Goals
- Business modules are pluggable.
- Core wallet capabilities have clear boundaries.
- Shell layers (CLI/iOS) reuse the same core capabilities.

## Layers

### 1) App Layer (`apps/*`)
- `apps/ios/AppShelliOS`: iOS UI shell responsible for UI rendering and navigation orchestration.
- `apps/cli/AppShell`: CLI shell for local integration and automated verification.

### 2) Runtime Layer (`packages/CoreRuntime`)
- Module protocol (`ModuleManifest`)
- Permission model (`PermissionManaging`)
- Routing and context (`RuntimeContext`)
- Namespaced storage (`InMemoryStorageHub`)

### 3) Capability Layer
- `packages/SecurityCore`: account management, signing, and transaction sending.
- `packages/BackendAPI`: business APIs and model adapters.
- `packages/WebDAppContainer`: DApp bridge capabilities.

### 4) Module Layer (`modules/*`)
- Each module declares its own manifest and extension points.
- Modules are wired into the shell runtime through the registry.

## Module Assembly Flow
1. The shell loads module definitions generated by `GeneratedModuleRegistry`.
2. `AppRuntime` installs manifests and builds route indexes.
3. Modules access controlled capabilities through `RuntimeContext`.
4. Permissions are managed centrally by `PermissionManager`.

## Engineering Constraints
- Keep business logic in `packages`/`modules`; shell projects handle assembly and presentation only.
- Use semantic directory layering; avoid scattering code by low-level technical details.
- Use `Makefile` as the unified entry point for development commands.

## iOS State Domains (`apps/ios/AppShelliOS/Sources/State`)
- `AppStore`: app facade holding `AppState` and domain stores; the single entry point for the UI layer.
- `SessionStore`: session domain (login state, addresses, network environment).
- `HomeStore`: home domain (balance, messages, transfer summary).
- `MeStore`: profile domain (profile, bills, address book, settings).
- `ReceiveStore`: receive domain (network selection, address lifecycle, sharing).
- `TransferStore`: transfer domain (network, address candidates, order creation, payment).
- `UIStore`: UI states such as Toast/Loading/Error.

> Current strategy: keep `AppState` as a compatibility layer while introducing domain stores for decoupling.
> Current status: views have migrated away from direct `AppState` usage and now consume domain stores via `AppStore` (`SessionStore/HomeStore/MeStore/ReceiveStore/TransferStore/UIStore`).

## iOS Navigation Contract
- Root container: `HomeShellView` maintains `homePath` and `mePath` navigation paths.
- Root pages (Home, Me):
  - Hide system navigation bar.
  - Keep bottom TabBar persistent.
- Child pages (push navigation):
  - Use system inline navigation bar.
  - Hide TabBar by default for immersive flows.
  - Route layer controls only TabBar visibility, not page background wrapping.
- Debounce repeated navigation taps with `NavigationGuard` cooldown.

## Safe Area Standards
- Root pages use `TopSafeAreaHeaderScaffold`:
  - Inject fixed header with `safeAreaInset(edge: .top)`.
  - Content scrolls from below the header.
  - Do not use fixed pixels (for example `topClearance`) for device adaptation.
- Child pages use `SafeAreaScreen`:
  - Internally reuse `FullscreenScaffold` for consistent background and safe-area rules.
  - Background can be full-screen (`ignoresSafeArea`), content must respect safe areas.
  - Inject fixed bottom actions with `safeAreaInset(edge: .bottom)`.
- Use `GlobalFullscreenBackground` for consistent full-screen and orientation behavior.
- Avoid double containers: do not stack route-level `fullscreenScaffold` inside page-level scaffolds.

## iOS Layer Boundaries (AppShelliOS)
- `Sources/Views`: rendering, interaction, and navigation triggers only.
- `Sources/State`: state aggregation and publishing (minimal `@Published` fields).
- `Sources/Domain/UseCases`: domain orchestration built on `AppState` capabilities.
- `Sources/Data`: repository/service adapter layer isolating backend and chain access details.
- `Sources/Infrastructure`: foundational capabilities (DI, formatting, error mapping, logging).

> Compatibility rule: `AppState` keeps external method signatures and semantics stable while delegating internally to use cases.

## Unified List and Input Standards
- Stable identity: list rows use `StableRowID`; using `index` as the sole identifier is prohibited.
- Pagination gate: use `PaginationGate` to prevent duplicate requests and out-of-order append.
- Address parsing: normalize scan/input through `AddressInputParser`; avoid per-view regex/trimming logic.
- Snapshot aggregation: use `BillSectionSnapshot` and rebuild on data changes to avoid recomputation in view `body` cycles.

## Dependency Injection Conventions
- Unified DI entry: `AppDependencies`
- Protocol boundaries:
  - `BackendServing`
  - `SecurityServing`
  - `PasskeyServing`
  - `AppClock`
  - `AppIDGenerator`
  - `AppLogger`
- `AppState` must support injected construction while preserving default `init()` production behavior.
- Unit tests should prefer fake clock/fake ID/fake logger to reduce system-time and side effects.

## Concurrency and Task Lifecycle Standards
- Do not block critical UI paths (for example semaphore-based network blocking).
- `onChange + Task` must have cancellation strategy (`task(id:)` or explicit `Task` handle).
- Use cancellable `Task.sleep` for delays; avoid non-cancellable `DispatchQueue.main.asyncAfter`.
- Long-running flows and polling loops must check `Task.isCancelled`.
- UI state writes must stay within `@MainActor` boundaries.

## Dead Code Cleanup Entry Criteria
- Deletions must satisfy both conditions:
  1. Repository-wide reference scan is zero (`rg` evidence).
  2. All three gates pass: `make swift-build`, `make swift-test`, `make ios-build`.
- Keep deletion changes in a separate commit for independent rollback.
- For compatibility layers in migration, converge callers first, then remove old entry points.

## Logging and Sensitive Data Standards
- Keep logs minimal by default; never print full addresses, full transaction hashes, tokens, or other sensitive values.
- Mask addresses/hashes before logging (keep prefix/suffix, mask the middle).
- Prefer structured short error messages; avoid exposing raw low-level exceptions directly to end users.

## iOS Test Baseline
- Test target: `AppShelliOSTests`
- Command entry: `make ios-test`
- CI should run:
  - `make swift-build`
  - `make swift-test`
  - `make ios-build`
  - `make ios-test`
